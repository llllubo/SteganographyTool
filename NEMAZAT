# BOLO BY MOZNE VYMYSLIET TAKMER NESPOCETNE MNOZSTVO EKVIVALENTNYCH SAD INSTRUKCII, ak by sme nemuseli dodrzat velkost povodnej...

# XCHG EAX, EAX     -> 90
# MOV EAX, EAX      -> 89 C0
# MOVSXD EAX, EAX   -> 63 C0
# '-> pre 64-bit je EAX extended with zeroes instead of signed extended (preto su 32 a 64-bitove instrukcie kompatibilne), pricom NOP nechava EAX neporuseny.
# THE POINT IS NOT ALL ASSMEBLERS CAN ENCODE 'XCHG EAX, EAX' CORRECTLY IN 64-BIT MODE.
# BUT
# MOVSXD RAX, EAX funguje OK (extended with sign) -> OPCODE: 48:63 C0
# MOV RAX, RAX tiez OK -> OPCODE: 48:89 C0
# XCHG RAX, RAX tiez OK -> OPCODE: 48:90 => zmenilo sa na NOP
# LEA RAX, [RAX + 0x00] OK -> OPCODE: 48:8D4000
# OPCODES s 48 prefixom v 32-bit rezime nie su
# VYSSIE UVEDENE NEMENIA ZIADNE FLAGS
# cele toto uz je v 'klassy' ale mam to aj tu, lebo tie vety su dolezite

########## ^^ dobre myslienky (mozno este pouzijem)


ARGUMENTS (len pre prehlad):
 - embed:
    INPUT -> COVER_FILE a SECRET_MESSAGE + METHOD
    OUTPUT -> STEGO-FILE (do ./stego zlozky bez zmeny nazvu -- moznost volby)
 - extract:
    INPUT -> STEGO-FILE + METHOD
    OUTPUT -> SECRET_MESSAGE (./extracted)
        '-> sys.stdout.buffer.write(b"some binary data WOW!")
 - analyze:
    INPUT -> COVER_FILE + METHOD
    OUTPUT -> text na stdout (mozne len presmerovat do suboru)
 - reset:
    INPUT -> STEGO-FILE + METHOD
    OUTPUT -> nic (zmeni sa zadany stego-file)
# -dzFfM intel
# -h vypise vsetky pritomne sections - viem napr. zistit ci su pritomne debug info


DOKUMENTACIA (aby som nezabudol):
pdoc
    pdoc ./src/args_parser.py src/thesis.py -o ./doc --logo "fit_logo.png" --logo-link "fit_logo.png" --footer-text "FOOTER TEXT" --favicon "vut_logo.ico"

pydoctor
    pydoctor ./src/thesis.py ./src/args_parser.py --html-output ./pydoctor --project-name "Steganography for Executables" --project-base-dir src --make-html
    
    --doc-format {epytext, google, numpy, plaintext, restructuredtext}
    --project-version VERSION
    --project-url URL
    --theme THEME
    --buildtime TIME ??

sphinx-apidoc ./src -efP -o ./sphinx/ --suffix html


METODY (Z ARTICLES):

 - Z HYDANU:
add eax, 50  ==  sub eax, -50
xor eax, eax ==  sub eax, eax
             ==? mov eax, 0         ## ine dlzky opcodes
             ==? and eax, 0
             ==? add eax, -eax
opcodes ine pre 'op r/m, reg' a 'op reg, r/m'
pouzivaju wildcard pre niektore sady instrukcii
sifruju spravu s Blowfish, predpokladaju aj AES
skumat ci je instrukcia ktora testuje zmeneny priznak
    (dalej v kode az kym nie je koniec funkcie alebo kym nepride
    instrukcia ktora nastavi tento kontrolovany priznak)
    odlisne nastavene priznaky instrukcii
vyXORuje sa dlzka s heslom a ulozi sa len tato sifra namiesto dlzky spravy
urci sa umiestnenie instrukcii v kode, kde sa vlozia bity spravy
    random-walk algorithm (seed je heslo)
    stazenie detekcie techniky
    kuk v Hydane - zdroj [1]
(len tri pokusy na heslo a cakat 15min na dalsie tri pokusy? -- predide sa DA)
 - NAVRHOVANE VYLEPSENIA HYDANU:
analyza mrtveho kodu cez CFG
'-> krokovanie programu a znacenie navstivenych instrukcii
    tie ktore by boli neoznacene je mozne zamienat lubovolne
    POZOR: metoda poskytuje len minimalne mnozstvo mrtveho kodu,
    dalsie mrtve kody by mohli vznikat v zavislosti od vstupu atd.
    RISENIE: staticky prepojene kniznice, z ktorych sa pouziva len male
    mnozstvo kodu - zbytok je mozne nahradit niecim co vyzera ako
    assembler na zakodovanie spravy
zmena poradia funkcne nezavislych blokov kodu
'-> TU JE VYSVETLENE KODOVANIE PORADIM (faktorialy)
    zlepsenie substitucie z 1/110 na 1/80
zmena poradia argumentov funkcii
poradie argumentov v ktorom sa pushuju na zasobnik
volba pridelenia registra -- NEBUDE FUNGOVAT
.got, .plt, .vtables, .ctors a .dtors tabulky
preusporiadanie dat v .data, .rodata, .bss
odhad zlepsenia pri pouziti poradia funkcii a tabuliek .got, .plt, .ctors
    a .dtors by zlepsilo rychlost na 1/36
POZRIET NA MESSAGE AUTHENTICATION CODE -- overovaci kod spravy
    tiez kuk na ECC na pokus pre obnovenie casti spravy v pripade zmeny

- ZO STILO:
tvorba ekvivalencnych tried
    dst a src budu rovnake ako v povodnej instrukcii
    instrukcie s imm operandom su rozsirene o negovane imm
instruction sequence
    obmedzenie mnozstva permutacii v ramci basic bloku bolo nastavene na 1024
CHECK EVALUATION Z STEGANOGRAPHY FOR EXECUTABLES
    pise sa tam co presne sa testovalo -- pre porovnanie..


##### STARE KODY (mozno sa este zidu?):

############### ZAPIS v pripade do NOPov multibytes
# nulls = 5
# hex_string = "0x9876543210"
# mess = bytes.fromhex(hex_string[2:])
# # Must compute offset for multi-byte NOPs like that.
# offset = potential_instrs[1].foffset + potential_instrs[1].instruction.len - nulls

# try:
#     fd = open("aa", "r+b")
# except IOError:
#     print("ERROR! ", file=sys.stderr)
# else:
#     fd.seek(offset)
#     # fd.seek(0x1b9b7d)
#     fd.write(mess)
#     fd.close()
################

####### len skusam, lebo dlhe NOPy s prefixmi su zle encodovane
# try:
#     fd = open(inputf, "rb")
# except IOError:
#     print("ERROR ....")
#     sys.exit(1000)
# fd.seek(my_instr.foffset)
# b_instr = fd.read(my_instr.instruction.len)
# fd.close()
# print(f"{b_instr.hex():20}", end="\t")
#######

##########
""""ZISKAVANIE BITOV Z BAJTOV NA POZICIACH"""
# 0x0054_3210 == 0b0000_0000_0101_0100_0011_0010_0001_0000
i = int("0x543210", 16)
print("0x{i:x}".format(i=i))
# getting bit at position 28 (counting from 0 from right)
val = i >> 4 & 1
print(f"0x{val:06x}")
# getting bits at position 20-24
print("{num}".format(num=bin(i >> 20 & 0b1111)))
print("0x{num:06x}".format(num=i >> 20 & 0b1111))
##########

##########
# Dump executable as it is going to be parsed.
# try:
#     b_objdumped = subprocess.check_output(
#         ["objdump", "-dzFM", "intel", inputf],
#         stderr=subprocess.STDOUT
#         )
# except subprocess.CalledProcessError:
#     print(f"ERROR! File was not recognized as executable: {inputf}", file=sys.stderr)
#     sys.exit(101)

# objdumped = b_objdumped.decode("UTF-8")
# print(objdump)
##########